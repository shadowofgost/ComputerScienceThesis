<!--
 * @Author           : Albert Wang
 * Copyright Notice : Copyright (c) 2022 Albert Wang 王子睿, All Rights Reserved.
 * @Time             : 2022-01-27 23:37:15
 * @Description      :
 * @Email            : shadowofgost@outlook.com
 * @FilePath         : /WebBackend/整体技术框架设计.md
 * @LastAuthor       : Albert Wang
 * @LastTime         : 2022-01-28 17:22:18
 * @Software         : Vscode
-->
# 功能模块设计
## 登录模块
### 前端：
1. 接收到用户名和密码，发送给后端，后端进行验证，返回结果。
2. 根据不同的权限值跳转到不同的页面（管理员，老师，学生）或者报错刷新页面
3. 实现路由守卫功能，同时结合token进行验证，收到token过期的信息后跳转到登录页面
### 后端：
1. 根据收到的用户名密码，查询数据库，返回结果。
2. 返回错误的结果，设置错误代码和错误格式。
3. 登录成功返回token，同时将token的校验结合进中间件中（你现在没有做token校验和token失效后返回的数据。）



## id验证模块和nouser（学号）验证模块
### 前端：
1. 只要出现修改/需要接收到id，选择需要判断的类型，发送给后端，后端验证，返回结果。
2. 根据判断结果，显示合法或者不合法，是否允许提交操作
### 后端：
1. 根据收到的id和需要判断的类型，查询数据库，返回结果。写成service模块

## 前端设计：
前端在涉及到外键时，设计一个链接，按照链接能跳转到对应的页面，展示相应的详细数据，比如ID_speaker外连用户，那么点击后能直接看到用户的详细信息，（只在查页面生效）
## 设备信息模块
### 前端：
1. 删（delete），实现批量删除和定点删除，一个是统计到整个的数量，一个是把需要删除的id全部传过来，具体看接口文档格式**这个是全部增删通用接口，只要涉及删都是这个接口，注意复用性**
2. 增（post），按照接口文档格式验证数据合理性，符合接口数据标准才允许提交返回，实现增加设备信息，分为批量添加和单个添加，接口形式是批量添加的形式，如果单个添加可以设定数据量为1，返回结果。**注意几点要求**：（1）有些字段代表着数据库的外键，需要先通过id验证接口验证id的存在或者因为涉及到user用户验证用户的学号/职工号存在，一旦修改就验证，验证存在后再允许提交（2）外键字段涉及到相关字段的不允许填写，只允许ID验证，比如ID_Speaker字段，表示演讲者的id，但是填写时填写的是nouser也就是学号/教职工号，通过id验证模块查询是否存在，然后把相应的id填进ID_Speaker中允许提交。
3. 改（patch），按照接口文档格式验证数据合理性，符合接口数据标准才允许提交返回，实现修改设备信息，分为批量修改和单个修改，接口形式是批量修改的形式，如果单个修改可以设定数据量为1，返回结果。**注意几点要求**：（1）不是所有字段都需要返回，只有修改后的字段才需要返回（2）有些字段代表着数据库的外键，需要先通过id验证接口验证id的存在或者因为涉及到user用户验证用户的学号/职工号存在，一旦修改就验证，验证存在后再允许提交（3）外键字段涉及到相关字段的不允许填写，只允许ID验证，比如ID_Speaker字段，表示演讲者的id，但是填写时填写的是nouser也就是学号/教职工号，通过id验证模块查询是否存在，然后把相应的id填进ID_Speaker中允许提交。
4. 查（get）：设计一个查询表单，类似于怎删改接口，根据表单信息填写查询条件，返回结果。也可以自定义查询条件，但是必须结合到一个接口中实现。
### 后端：
接口只是接口，只是直接调用return service对应结果的作用。
后端可以想一下，如果service大体相同，是否可以抽象成一个函数，然后不同的参数由Api层传入设定。
1. 删（delete），根据传过来的数据数量决定使用单个数量删除还是全部删除**这个是删除的通用service，写成公用的servcie然后给不同的api接口调用。**
2. 增（post），首先对不同的Model建立不同的Model文件，然后写增删查函数，依据传回来的数据，判断是否是单个增加还是批量增加，如果是单个增加，则直接调用单个增加函数，如果是批量增加，则调用批量增加函数。（本质是对ORM函数进行一层封装，封装成服务模块）具体使用开会会讲。[补充一个功能，对于需要ORM操作的数传入ORM实体类之前先通过id验证，也就是调用id的service进行验证，验证通过才能进行ORM操作，否则返回错误信息]
3. 改（patch），和增同样的要求
4. 查（get）：根据返回的条件，判断是查询姓名还是查询特定的表的数据值还是构造特殊查询，api接口只能是一个也就是一个函数，但是service可以是很多个，注意函数的复用性。


## 所有用户信息管理模块（ModelUser，ModelUserExtension）
整个前后端参考设备信息管理模块，本质还是增删改查。，注意几点
1. 后端数据库实现了垂直分表，所以前端实现的时候业务逻辑为，先查询User表，再根据User表的id查询对应UserExtension的表，（查看详细信息才操作。）
2. 进行增删改的时候分开进行，前端将数据封装到一起给后端，后端根据数据结构先对主表进行操作，然后对从表操作（从逻辑上来说，只有增的时候必须主先从后，改和删完全可以把两个表当作不相关的表操作）
### 前端：
### 后端：

## 其他用户的信息修改：比如照片，身份证等，只能修改自己的。
前端单独设计，后端复用接口模块（具体怎么复用自己想，不难）
## 部门表管理模块（ModelDepartment），类别管理模块（ModelType）
参照设备信息管理模块
### 前端：
### 后端：
## 地点表管理模块（ModelLocation），媒体信息管理模块（ModelMmxData）
参照用户表进行设计
以上的后端由韩泰来完成，蔡晓元优先完成韩泰来的接口。以上为管理员独有端口

以下功能后端王子睿实现
## 课程管理模块（ModelCurricula）
## 前端：（老师，管理员，学生都有，增删改只有管理员有功能，教师学生的只有查。）
1. 正常的单表增删改查，但是注意，给一个额外的按钮，点击以后可以查询这个课的对应的课程安排（新的页面，左侧不变，右侧刷新）
## 后端：
1. 查询模块复用，后端依据权限不同返回不同的数据实现不同人不同功能
## 课程安排模块（ModelCoursePlan）
## 前端：
课程管理模块类似，查询根据角色不同实现不一样。
## 后端：
课程管理模块类似，注意内容的复用性
## 考勤管理模块（ModelRunningAccount）
**重点中的重点**
## 前端：
1. 管理员有权限对其本身实现增删改查（当成单表处理）
2. 从课程安排模块点击可以看到每一次的考勤结果，也就是进入对应的考勤管理页面（和课程管理进到课程安排一样。）
3. 在教室端，首先看到自己的所有课程，点击后其次看到所有课程安排，点击课程安排看到所有的考勤结果，可以对考勤结果进行修改（只实现查改功能）
4. 在学生端，首先看到自己的所有课程，点击后可以看到自己的每次课程安排的出勤结果
